<!DOCTYPE html>
<html>
<head>
  <title>Tetris Mini App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin:0; background:#222; display:flex; justify-content:center; align-items:center; flex-direction:column; height:100vh; color:white; font-family:sans-serif; }
    canvas { background:#000; }
    .score { margin:10px; font-size:18px; }
  </style>
</head>
<body>
  <div class="score">Điểm: <span id="score">0</span></div>
  <canvas id="game" width="200" height="400"></canvas>

  <script>
    const canvas=document.getElementById('game');
    const ctx=canvas.getContext('2d');

    const ROW=20, COL=10, CELL=20;
    let board=Array.from({length:ROW},()=>Array(COL).fill(0));
    let score=0;

    const COLORS=[null,'cyan','blue','orange','yellow','green','purple','red'];
    const SHAPES=[[],[[1,1,1,1]],[[2,0,0],[2,2,2]],[[0,0,3],[3,3,3]],[[4,4],[4,4]],[[0,5,5],[5,5,0]],[[0,6,0],[6,6,6]],[[7,7,0],[0,7,7]]];

    let piece={matrix:SHAPES[1], x:3, y:0};

    function drawCell(x,y,color){
      ctx.fillStyle=color;
      ctx.fillRect(x*CELL,y*CELL,CELL,CELL);
      ctx.strokeStyle="#111";
      ctx.strokeRect(x*CELL,y*CELL,CELL,CELL);
    }

    function draw(){
      ctx.fillStyle="#000";
      ctx.fillRect(0,0,COL*CELL,ROW*CELL);

      for(let y=0;y<ROW;y++){
        for(let x=0;x<COL;x++){
          if(board[y][x]) drawCell(x,y,COLORS[board[y][x]]);
        }
      }

      for(let y=0;y<piece.matrix.length;y++){
        for(let x=0;x<piece.matrix[y].length;x++){
          if(piece.matrix[y][x]) drawCell(piece.x+x,piece.y+y,COLORS[piece.matrix[y][x]]);
        }
      }
    }

    function collide(){
      for(let y=0;y<piece.matrix.length;y++){
        for(let x=0;x<piece.matrix[y].length;x++){
          if(piece.matrix[y][x] && (board[y+piece.y] && board[y+piece.y][x+piece.x])!==0) return true;
        }
      }
      return false;
    }

    function merge(){
      for(let y=0;y<piece.matrix.length;y++){
        for(let x=0;x<piece.matrix[y].length;x++){
          if(piece.matrix[y][x]) board[piece.y+y][piece.x+x]=piece.matrix[y][x];
        }
      }
    }

    function sweep(){
      for(let y=ROW-1;y>=0;y--){
        if(board[y].every(v=>v!==0)){
          board.splice(y,1);
          board.unshift(Array(COL).fill(0));
          score+=10;
        }
      }
      document.getElementById('score').textContent=score;
    }

    function resetPiece(){
      const idx=Math.floor(Math.random()*SHAPES.length);
      piece.matrix=SHAPES[idx]||SHAPES[1];
      piece.x=3;
      piece.y=0;
      if(collide()) board=Array.from({length:ROW},()=>Array(COL).fill(0));
    }

    function rotate(){
      const m=piece.matrix;
      const N=m.length; 
      let r=Array.from({length:N},()=>Array(N).fill(0));
      for(let y=0;y<N;y++){
        for(let x=0;x<N;x++){
          r[x][N-1-y]=m[y][x];
        }
      }
      piece.matrix=r;
      if(collide()) piece.matrix=m;
    }

    function move(dir){
      piece.x+=dir;
      if(collide()) piece.x-=dir;
    }

    function drop(){
      piece.y++;
      if(collide()){
        piece.y--;
        merge();
        sweep();
        resetPiece();
      }
    }

    // Keyboard controls
    document.addEventListener('keydown',e=>{
      if(e.key==='ArrowLeft') move(-1);
      if(e.key==='ArrowRight') move(1);
      if(e.key==='ArrowDown') drop();
      if(e.key==='ArrowUp') rotate();
    });

    // Swipe controls for mobile
    let startX=0, startY=0;
    canvas.addEventListener('touchstart',e=>{ startX=e.touches[0].clientX; startY=e.touches[0].clientY; });
    canvas.addEventListener('touchend',e=>{
      let dx=e.changedTouches[0].clientX-startX;
      let dy=e.changedTouches[0].clientY-startY;
      if(Math.abs(dx)>Math.abs(dy)){
        if(dx>20) move(1);
        else if(dx<-20) move(-1);
      }else{
        if(dy>20) drop();
        else if(dy<-20) rotate();
      }
    });

    let lastTime=0, dropCounter=0, dropInterval=500;
    function update(time=0){
      const delta=time-lastTime;
      lastTime=time;
      dropCounter+=delta;
      if(dropCounter>dropInterval){ dropCounter=0; drop(); }
      draw();
      requestAnimationFrame(update);
    }
    update();
  </script>
</body>
</html>
